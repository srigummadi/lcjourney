===============
Template
===============

PriorityQueue<T> pq = new PriorityQueue<T>();

Default is min heap.
PriorityQueue<Integer> heap = new PriorityQueue<Integer>((n1, n2) -> n1 - n2);

For max heap
PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> (b-a));

Note : Add min_heapify and max_heapify functions for actual PQ implementations

253 : Meeting Rooms II
===========================
https://leetcode.com/problems/meeting-rooms-ii/

Simple logic: the meeting which has early time should start early . Hence we will first sort the input on the basis of start time , then we will have to see the meeting which end first so we use priority queue and pq peek should give the meeting which gets finish early .

class Solution {
    public int minMeetingRooms(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->a[0]-b[0]);
        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);
        
        for(int[] arr:intervals){
            if(pq.isEmpty()) pq.add(arr);
            else{
                if(pq.peek()[1]<=arr[0]){
                    pq.poll();
                }
                pq.offer(arr);
            }
        }
        return pq.size();
    }
}


215 : Kth largest element in an array
======================================
	//QuickSelect is the optimized approach for this problem
    //https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/2180600/A-Guide-to-Quick-Select-or-JAVA
    
    public int findKthLargest(int[] nums, int k) {
        // PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> (b-a));
        // for(int n :nums)
        //     pq.add(new Integer(n));
        // for(int i=0;i<k-1;i++)
        //     pq.poll();
        // return pq.peek();
        
        //Ideal way is to create a min heap and save the n-k smallest elements
        //At the end the element on the top is the kth largest element.
        //Less TC
        
        // init heap 'the smallest element first'
        PriorityQueue<Integer> heap =
            new PriorityQueue<Integer>((n1, n2) -> n1 - n2);

        // keep k largest elements in the heap
        for (int n: nums) {
          heap.add(n);
          if (heap.size() > k)
            heap.poll();
        }

        // output
        return heap.poll();   
    }
	
	
973 : K closest points to origin
https://leetcode.com/problems/k-closest-points-to-origin/

//PQ approach is one of the solutions
// Optimized is quick select
    public int[][] kClosest(int[][] points, int k) {
        int[][] result = new int[k][2];
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((p,q) -> (
            (p[0]*p[0]+p[1]*p[1]) - (q[0]*q[0]+q[1]*q[1])
        ));
        for(int[] n : points){
            pq.add(n);
        }   
        for(int i=0;i<k;i++){
            int[] r = pq.poll();
            result[i][0]=r[0];
            result[i][1]=r[1];
        }
        return result;                                                 
    }
	

347 : Top K frequent elements
=================================
https://leetcode.com/problems/top-k-frequent-elements/

public int[] topKFrequent(int[] nums, int k) {
        
        //Approach 1 : TC : O(n), SC : O(n)
        Map<Integer,Integer> freqMap = new HashMap<Integer,Integer>();
        for (int n : nums){
            freqMap.put(n, freqMap.getOrDefault(n,0)+1);
        }
        
        List<Integer>[] buckets = new List[nums.length + 1];
        for(Integer i : freqMap.keySet()){
            Integer freq = freqMap.get(i);
            if(buckets[freq]==null)
                buckets[freq]=new ArrayList<Integer>();
            buckets[freq].add(i);
        }
        List<Integer> result = new ArrayList<Integer>();
        for (int j=buckets.length-1;j>=0 && result.size()<k;j--){
            if(buckets[j]!=null){
                result.addAll(buckets[j]);
            }
        }
        return result.stream().mapToInt(i -> i).toArray();
    }