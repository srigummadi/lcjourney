===============
Template
===============

PriorityQueue<T> pq = new PriorityQueue<T>();

Default is min heap.
PriorityQueue<Integer> heap = new PriorityQueue<Integer>((n1, n2) -> n1 - n2);

For max heap
PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> (b-a));


253 : Meeting Rooms II
https://leetcode.com/problems/meeting-rooms-ii/

Simple logic: the meeting which has early time should start early . Hence we will first sort the input on the basis of start time , then we will have to see the meeting which end first so we use priority queue and pq peek should give the meeting which gets finish early .

class Solution {
    public int minMeetingRooms(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->a[0]-b[0]);
        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);
        
        for(int[] arr:intervals){
            if(pq.isEmpty()) pq.add(arr);
            else{
                if(pq.peek()[1]<=arr[0]){
                    pq.poll();
                }
                pq.offer(arr);
            }
        }
        return pq.size();
    }
}


215 : Kth largest element in an array

	//QuickSelect is the optimized approach for this problem
    //https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/2180600/A-Guide-to-Quick-Select-or-JAVA
    
    public int findKthLargest(int[] nums, int k) {
        // PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> (b-a));
        // for(int n :nums)
        //     pq.add(new Integer(n));
        // for(int i=0;i<k-1;i++)
        //     pq.poll();
        // return pq.peek();
        
        //Ideal way is to create a min heap and save the n-k smallest elements
        //At the end the element on the top is the kth largest element.
        //Less TC
        
        // init heap 'the smallest element first'
        PriorityQueue<Integer> heap =
            new PriorityQueue<Integer>((n1, n2) -> n1 - n2);

        // keep k largest elements in the heap
        for (int n: nums) {
          heap.add(n);
          if (heap.size() > k)
            heap.poll();
        }

        // output
        return heap.poll();   
    }